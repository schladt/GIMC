#!/usr/bin/env python3
"""
PE File Collection Utility

Recursively searches a directory tree for Windows PE32/PE32+ executable files
(EXE and optionally DLL) and copies them to an output directory using their
SHA256 hash as the filename.

This script is optimized for performance when processing large directory trees:
- Checks file size before reading
- Validates PE magic bytes before computing hash
- Uses efficient file I/O operations
"""

import argparse
import hashlib
import os
import shutil
import struct
import sys
from pathlib import Path
from typing import Optional


# PE file constants
PE_SIGNATURE = b'PE\0\0'
DOS_SIGNATURE = b'MZ'
PE_SIGNATURE_OFFSET_LOCATION = 0x3C

# PE machine types
IMAGE_FILE_MACHINE_I386 = 0x014c  # x86
IMAGE_FILE_MACHINE_AMD64 = 0x8664  # x64

# PE characteristics flags
IMAGE_FILE_DLL = 0x2000
IMAGE_FILE_EXECUTABLE_IMAGE = 0x0002


class PEFileInfo:
    """Information about a PE file."""
    def __init__(self, is_dll: bool, is_exe: bool):
        self.is_dll = is_dll
        self.is_exe = is_exe


def is_pe_file(file_path: Path) -> Optional[PEFileInfo]:
    """
    Check if a file is a valid PE32/PE32+ file and determine if it's an EXE or DLL.
    
    Args:
        file_path: Path to the file to check
        
    Returns:
        PEFileInfo object if valid PE file, None otherwise
    """
    try:
        with open(file_path, 'rb') as f:
            # Check DOS header (MZ signature)
            dos_header = f.read(2)
            if dos_header != DOS_SIGNATURE:
                return None
            
            # Read offset to PE signature
            f.seek(PE_SIGNATURE_OFFSET_LOCATION)
            pe_offset_bytes = f.read(4)
            if len(pe_offset_bytes) != 4:
                return None
            
            pe_offset = struct.unpack('<I', pe_offset_bytes)[0]
            
            # Check PE signature
            f.seek(pe_offset)
            pe_sig = f.read(4)
            if pe_sig != PE_SIGNATURE:
                return None
            
            # Read COFF header to get characteristics
            # Machine (2 bytes) + NumberOfSections (2 bytes) + TimeDateStamp (4 bytes)
            # + PointerToSymbolTable (4 bytes) + NumberOfSymbols (4 bytes) + 
            # SizeOfOptionalHeader (2 bytes) + Characteristics (2 bytes)
            coff_header = f.read(20)
            if len(coff_header) < 20:
                return None
            
            machine = struct.unpack('<H', coff_header[0:2])[0]
            characteristics = struct.unpack('<H', coff_header[18:20])[0]
            
            # Verify it's a valid machine type (x86 or x64)
            if machine not in (IMAGE_FILE_MACHINE_I386, IMAGE_FILE_MACHINE_AMD64):
                return None
            
            # Check if it's executable
            if not (characteristics & IMAGE_FILE_EXECUTABLE_IMAGE):
                return None
            
            # Determine if DLL or EXE
            is_dll = bool(characteristics & IMAGE_FILE_DLL)
            is_exe = not is_dll
            
            return PEFileInfo(is_dll=is_dll, is_exe=is_exe)
            
    except (IOError, OSError, struct.error):
        return None


def compute_sha256(file_path: Path) -> str:
    """
    Compute SHA256 hash of a file efficiently.
    
    Args:
        file_path: Path to the file
        
    Returns:
        Hexadecimal string of the SHA256 hash
    """
    sha256_hash = hashlib.sha256()
    
    with open(file_path, 'rb') as f:
        # Read in 64KB chunks for efficiency
        for chunk in iter(lambda: f.read(65536), b''):
            sha256_hash.update(chunk)
    
    return sha256_hash.hexdigest()


def collect_pe_files(
    root_dir: Path,
    output_dir: Path,
    max_size_bytes: int,
    include_dlls: bool
) -> dict:
    """
    Recursively collect PE files from root directory.
    
    Args:
        root_dir: Root directory to search
        output_dir: Directory to save collected files
        max_size_bytes: Maximum file size in bytes
        include_dlls: Whether to include DLL files
        
    Returns:
        Dictionary with collection statistics
    """
    stats = {
        'scanned': 0,
        'skipped_size': 0,
        'skipped_not_pe': 0,
        'skipped_dll': 0,
        'collected_exe': 0,
        'collected_dll': 0,
        'duplicates': 0,
        'errors': 0
    }
    
    collected_hashes = set()
    
    # Ensure output directory exists
    output_dir.mkdir(parents=True, exist_ok=True)
    
    print(f"[*] Scanning {root_dir}...")
    print(f"[*] Output directory: {output_dir}")
    print(f"[*] Max file size: {max_size_bytes / (1024*1024):.2f} MB")
    print(f"[*] Include DLLs: {include_dlls}")
    print()
    
    for file_path in root_dir.rglob('*'):
        # Skip directories
        if not file_path.is_file():
            continue
        
        # Skip if not .exe or .dll extension (quick filter)
        if file_path.suffix.lower() not in ['.exe', '.dll']:
            continue
        
        stats['scanned'] += 1
        
        # Show progress every 100 files
        if stats['scanned'] % 100 == 0:
            print(f"[*] Scanned {stats['scanned']} files, "
                  f"collected {stats['collected_exe']} EXEs"
                  f"{f', {stats["collected_dll"]} DLLs' if include_dlls else ''}...", 
                  end='\r')
        
        try:
            # Check file size first (most efficient filter)
            file_size = file_path.stat().st_size
            if file_size > max_size_bytes:
                stats['skipped_size'] += 1
                continue
            
            # Check if it's a valid PE file
            pe_info = is_pe_file(file_path)
            if pe_info is None:
                stats['skipped_not_pe'] += 1
                continue
            
            # Check if we should skip DLLs
            if pe_info.is_dll and not include_dlls:
                stats['skipped_dll'] += 1
                continue
            
            # Compute hash
            file_hash = compute_sha256(file_path)
            
            # Check for duplicates
            if file_hash in collected_hashes:
                stats['duplicates'] += 1
                continue
            
            # Determine extension
            extension = '.dll' if pe_info.is_dll else '.exe'
            output_path = output_dir / f"{file_hash}{extension}"
            
            # Copy file
            shutil.copy2(file_path, output_path)
            collected_hashes.add(file_hash)
            
            if pe_info.is_dll:
                stats['collected_dll'] += 1
            else:
                stats['collected_exe'] += 1
                
        except (IOError, OSError, PermissionError) as e:
            stats['errors'] += 1
            # Uncomment to see specific errors:
            # print(f"\n[!] Error processing {file_path}: {e}")
            continue
    
    print()  # Clear the progress line
    return stats


def parse_size(size_str: str) -> int:
    """
    Parse a size string like '10M' or '100MB' into bytes.
    
    Args:
        size_str: Size string with optional suffix (K, M, G)
        
    Returns:
        Size in bytes
    """
    size_str = size_str.upper().strip()
    
    # Extract number and suffix
    multipliers = {
        'K': 1024,
        'KB': 1024,
        'M': 1024 * 1024,
        'MB': 1024 * 1024,
        'G': 1024 * 1024 * 1024,
        'GB': 1024 * 1024 * 1024,
    }
    
    # Check for suffix
    for suffix, multiplier in multipliers.items():
        if size_str.endswith(suffix):
            number = size_str[:-len(suffix)].strip()
            try:
                return int(float(number) * multiplier)
            except ValueError:
                raise ValueError(f"Invalid size format: {size_str}")
    
    # No suffix, assume bytes
    try:
        return int(size_str)
    except ValueError:
        raise ValueError(f"Invalid size format: {size_str}")


def main():
    parser = argparse.ArgumentParser(
        description='Recursively collect Windows PE32/PE32+ files (EXE/DLL) and save them by SHA256 hash.',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Collect EXE files from C:\\ to output directory
  python collect_pe_files.py -o ./benign_samples

  # Collect from Program Files with 5MB limit
  python collect_pe_files.py -o ./samples -r "C:\\Program Files" -s 5M

  # Include DLLs with 20MB limit
  python collect_pe_files.py -o ./samples --include-dlls -s 20M

Size format: Use numbers with optional suffix K/KB, M/MB, G/GB
  Examples: 10M, 10MB, 1024K, 2G
        """
    )
    
    parser.add_argument(
        '-o', '--output',
        type=str,
        required=True,
        help='Output directory for collected files (required)'
    )
    
    parser.add_argument(
        '-r', '--root',
        type=str,
        default='C:\\',
        help='Root directory to search from (default: C:\\)'
    )
    
    parser.add_argument(
        '-s', '--max-size',
        type=str,
        default='10M',
        help='Maximum file size (default: 10M). Examples: 10M, 5MB, 1024K, 2G'
    )
    
    parser.add_argument(
        '--include-dlls',
        action='store_true',
        help='Include DLL files (default: only collect EXE files)'
    )
    
    args = parser.parse_args()
    
    # Parse paths
    root_dir = Path(args.root).resolve()
    output_dir = Path(args.output).resolve()
    
    # Validate root directory
    if not root_dir.exists():
        print(f"[!] Error: Root directory does not exist: {root_dir}", file=sys.stderr)
        return 1
    
    if not root_dir.is_dir():
        print(f"[!] Error: Root path is not a directory: {root_dir}", file=sys.stderr)
        return 1
    
    # Parse max size
    try:
        max_size_bytes = parse_size(args.max_size)
    except ValueError as e:
        print(f"[!] Error: {e}", file=sys.stderr)
        return 1
    
    # Collect files
    print(f"{'='*60}")
    print("PE File Collection Utility")
    print(f"{'='*60}")
    
    stats = collect_pe_files(
        root_dir=root_dir,
        output_dir=output_dir,
        max_size_bytes=max_size_bytes,
        include_dlls=args.include_dlls
    )
    
    # Print summary
    print()
    print(f"{'='*60}")
    print("Collection Summary")
    print(f"{'='*60}")
    print(f"Files scanned:           {stats['scanned']}")
    print(f"Skipped (too large):     {stats['skipped_size']}")
    print(f"Skipped (not PE):        {stats['skipped_not_pe']}")
    if not args.include_dlls:
        print(f"Skipped (DLL):           {stats['skipped_dll']}")
    print(f"Duplicates:              {stats['duplicates']}")
    print(f"Errors:                  {stats['errors']}")
    print(f"{'-'*60}")
    print(f"EXE files collected:     {stats['collected_exe']}")
    if args.include_dlls:
        print(f"DLL files collected:     {stats['collected_dll']}")
    print(f"Total collected:         {stats['collected_exe'] + stats['collected_dll']}")
    print(f"{'='*60}")
    print(f"[âœ“] Output directory: {output_dir}")
    
    return 0


if __name__ == '__main__':
    sys.exit(main())
