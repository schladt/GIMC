/*
 * Scheduled Task COM API Persistence BSI (Behavioral Subset Implementation)
 * 
 * Based on Carberp banking trojan's scheduled task persistence mechanism.
 * Demonstrates T1053.005 (Scheduled Task/Job: Scheduled Task) using COM APIs.
 * 
 * Behavior:
 * - Uses Task Scheduler 2.0 COM API (Windows Vista+)
 * - Creates scheduled task with time-based trigger (every 2 seconds)
 * - Executes JScript payload that writes timestamps to log file
 * 
 * Payload: Writes timestamp to C:\Users\Public\gimc_test.log
 * 
 * Cleanup: Use remove_task.js to remove the scheduled task
 */

#include <windows.h>
#include <comdef.h>
#include <taskschd.h>
#include <iostream>

const wchar_t* TASK_NAME = L"GIMCTestBSI";
const wchar_t* LOG_FILE = L"C:\\Users\\Public\\gimc_test.log";
const int LOOP_COUNT = 10;
const int LOOP_DELAY_MS = 1000;

// JScript payload - writes 10 timestamps with 1 second delay between each
const wchar_t* PAYLOAD_SCRIPT = 
    L"var fso = new ActiveXObject('Scripting.FileSystemObject');"
    L"for (var i = 0; i < 10; i++) {"
    L"  var f = fso.OpenTextFile('C:\\\\Users\\\\Public\\\\gimc_test.log', 8, true);"
    L"  var d = new Date();"
    L"  f.WriteLine('[' + d.toLocaleString() + '] Task executed (iteration ' + (i+1) + '/10)');"
    L"  f.Close();"
    L"  if (i < 9) { WScript.Sleep(1000); }"
    L"}";

class ScheduledTaskPersistence {
private:
    ITaskService* pService;
    ITaskFolder* pRootFolder;
    
public:
    ScheduledTaskPersistence() : pService(NULL), pRootFolder(NULL) {}
    
    ~ScheduledTaskPersistence() {
        if (pRootFolder) pRootFolder->Release();
        if (pService) pService->Release();
        CoUninitialize();
    }
    
    bool Initialize() {
        HRESULT hr;
        
        // Initialize COM
        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
        if (FAILED(hr)) {
            std::cerr << "[ERROR] CoInitializeEx failed: 0x" << std::hex << hr << std::endl;
            return false;
        }
        
        // Set COM security
        hr = CoInitializeSecurity(
            NULL, -1, NULL, NULL,
            RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
            RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL, 0, NULL
        );
        
        if (FAILED(hr)) {
            std::cerr << "[ERROR] CoInitializeSecurity failed: 0x" << std::hex << hr << std::endl;
            CoUninitialize();
            return false;
        }
        
        // Create Task Scheduler instance
        hr = CoCreateInstance(
            CLSID_TaskScheduler, NULL,
            CLSCTX_INPROC_SERVER,
            IID_ITaskService,
            (void**)&pService
        );
        
        if (FAILED(hr)) {
            std::cerr << "[ERROR] CoCreateInstance failed: 0x" << std::hex << hr << std::endl;
            CoUninitialize();
            return false;
        }
        
        // Connect to Task Scheduler service
        VARIANT vEmpty;
        VariantInit(&vEmpty);
        hr = pService->Connect(vEmpty, vEmpty, vEmpty, vEmpty);
        if (FAILED(hr)) {
            std::cerr << "[ERROR] Connect failed: 0x" << std::hex << hr << std::endl;
            return false;
        }
        
        // Get root task folder
        BSTR bstrRoot = SysAllocString(L"\\");
        hr = pService->GetFolder(bstrRoot, &pRootFolder);
        SysFreeString(bstrRoot);
        if (FAILED(hr)) {
            std::cerr << "[ERROR] GetFolder failed: 0x" << std::hex << hr << std::endl;
            return false;
        }
        
        std::cout << "[+] Connected to Task Scheduler" << std::endl;
        return true;
    }
    
    bool CreateTask() {
        HRESULT hr;
        
        // Delete existing task if present
        BSTR bstrTaskName = SysAllocString(TASK_NAME);
        pRootFolder->DeleteTask(bstrTaskName, 0);
        SysFreeString(bstrTaskName);
        
        // Create new task definition
        ITaskDefinition* pTask = NULL;
        hr = pService->NewTask(0, &pTask);
        if (FAILED(hr)) {
            std::cerr << "[ERROR] NewTask failed: 0x" << std::hex << hr << std::endl;
            return false;
        }
        
        // Create time-based trigger
        if (!CreateTimeTrigger(pTask)) {
            pTask->Release();
            return false;
        }
        
        // Set action (execute script)
        if (!SetAction(pTask)) {
            pTask->Release();
            return false;
        }
        
        // Set task settings
        if (!SetTaskSettings(pTask)) {
            pTask->Release();
            return false;
        }
        
        // Set registration info
        if (!SetRegistrationInfo(pTask)) {
            pTask->Release();
            return false;
        }
        
        // Register the task
        bool success = RegisterTask(pTask);
        pTask->Release();
        
        return success;
    }
    
private:
    bool CreateTimeTrigger(ITaskDefinition* pTask) {
        HRESULT hr;
        ITriggerCollection* pTriggerCollection = NULL;
        
        hr = pTask->get_Triggers(&pTriggerCollection);
        if (FAILED(hr)) {
            std::cerr << "[ERROR] get_Triggers failed: 0x" << std::hex << hr << std::endl;
            return false;
        }
        
        ITrigger* pTrigger = NULL;
        hr = pTriggerCollection->Create(TASK_TRIGGER_LOGON, &pTrigger);
        pTriggerCollection->Release();
        
        if (FAILED(hr)) {
            std::cerr << "[ERROR] Create trigger failed: 0x" << std::hex << hr << std::endl;
            return false;
        }
        
        ILogonTrigger* pLogonTrigger = NULL;
        hr = pTrigger->QueryInterface(IID_ILogonTrigger, (void**)&pLogonTrigger);
        pTrigger->Release();
        
        if (FAILED(hr)) {
            std::cerr << "[ERROR] QueryInterface failed: 0x" << std::hex << hr << std::endl;
            return false;
        }
        
        // Set trigger ID
        BSTR bstrTriggerId = SysAllocString(L"GIMCTrigger");
        pLogonTrigger->put_Id(bstrTriggerId);
        SysFreeString(bstrTriggerId);
        
        pLogonTrigger->Release();
        
        std::cout << "[+] Created logon trigger" << std::endl;
        return true;
    }
    
    bool SetAction(ITaskDefinition* pTask) {
        HRESULT hr;
        IActionCollection* pActionCollection = NULL;
        
        hr = pTask->get_Actions(&pActionCollection);
        if (FAILED(hr)) {
            std::cerr << "[ERROR] get_Actions failed: 0x" << std::hex << hr << std::endl;
            return false;
        }
        
        IAction* pAction = NULL;
        hr = pActionCollection->Create(TASK_ACTION_EXEC, &pAction);
        pActionCollection->Release();
        
        if (FAILED(hr)) {
            std::cerr << "[ERROR] Create action failed: 0x" << std::hex << hr << std::endl;
            return false;
        }
        
        IExecAction* pExecAction = NULL;
        hr = pAction->QueryInterface(IID_IExecAction, (void**)&pExecAction);
        pAction->Release();
        
        if (FAILED(hr)) {
            std::cerr << "[ERROR] QueryInterface failed: 0x" << std::hex << hr << std::endl;
            return false;
        }
        
        // For Task Scheduler, we need to save the script to a temporary file
        wchar_t tempPath[MAX_PATH];
        GetTempPathW(MAX_PATH, tempPath);
        std::wstring scriptPath = std::wstring(tempPath) + L"gimc_payload.js";
        
        // Write script to file
        HANDLE hFile = CreateFileW(scriptPath.c_str(), GENERIC_WRITE, 0, NULL, 
                                   CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile != INVALID_HANDLE_VALUE) {
            DWORD written;
            // Convert to UTF-8
            int size = WideCharToMultiByte(CP_UTF8, 0, PAYLOAD_SCRIPT, -1, NULL, 0, NULL, NULL);
            char* utf8Script = new char[size];
            WideCharToMultiByte(CP_UTF8, 0, PAYLOAD_SCRIPT, -1, utf8Script, size, NULL, NULL);
            WriteFile(hFile, utf8Script, size - 1, &written, NULL);
            delete[] utf8Script;
            CloseHandle(hFile);
        }
        
        BSTR bstrPath = SysAllocString(L"wscript.exe");
        pExecAction->put_Path(bstrPath);
        SysFreeString(bstrPath);
        
        std::wstring args = L"//NoLogo \"" + scriptPath + L"\"";
        BSTR bstrArgs = SysAllocString(args.c_str());
        pExecAction->put_Arguments(bstrArgs);
        SysFreeString(bstrArgs);
        
        pExecAction->Release();
        
        std::cout << "[+] Set action (execute script)" << std::endl;
        return true;
    }
    
    bool SetTaskSettings(ITaskDefinition* pTask) {
        HRESULT hr;
        ITaskSettings* pSettings = NULL;
        
        hr = pTask->get_Settings(&pSettings);
        if (FAILED(hr)) {
            return true;  // Not critical
        }
        
        pSettings->put_StartWhenAvailable(VARIANT_TRUE);
        pSettings->put_DisallowStartIfOnBatteries(VARIANT_FALSE);
        pSettings->put_StopIfGoingOnBatteries(VARIANT_FALSE);
        pSettings->Release();
        
        // Set principal (security context)
        IPrincipal* pPrincipal = NULL;
        hr = pTask->get_Principal(&pPrincipal);
        if (SUCCEEDED(hr)) {
            BSTR bstrLogonType = SysAllocString(L"InteractiveToken");
            pPrincipal->put_LogonType(TASK_LOGON_INTERACTIVE_TOKEN);
            SysFreeString(bstrLogonType);
            
            BSTR bstrRunLevel = SysAllocString(L"HighestAvailable");
            pPrincipal->put_RunLevel(TASK_RUNLEVEL_HIGHEST);
            SysFreeString(bstrRunLevel);
            
            pPrincipal->Release();
        }
        
        return true;
    }
    
    bool SetRegistrationInfo(ITaskDefinition* pTask) {
        HRESULT hr;
        IRegistrationInfo* pRegInfo = NULL;
        
        hr = pTask->get_RegistrationInfo(&pRegInfo);
        if (FAILED(hr)) {
            return true;  // Not critical
        }
        
        BSTR bstrAuthor = SysAllocString(L"GIMC");
        pRegInfo->put_Author(bstrAuthor);
        SysFreeString(bstrAuthor);
        
        BSTR bstrDesc = SysAllocString(L"GIMC Test BSI - Scheduled Task Persistence");
        pRegInfo->put_Description(bstrDesc);
        SysFreeString(bstrDesc);
        
        pRegInfo->Release();
        
        return true;
    }
    
    bool RegisterTask(ITaskDefinition* pTask) {
        HRESULT hr;
        IRegisteredTask* pRegisteredTask = NULL;
        
        BSTR bstrTaskName = SysAllocString(TASK_NAME);
        
        // Use empty variants like Carberp does
        VARIANT vEmpty;
        VariantInit(&vEmpty);
        vEmpty.vt = VT_EMPTY;
        
        VARIANT vPassword;
        VariantInit(&vPassword);
        vPassword.vt = VT_EMPTY;
        
        hr = pRootFolder->RegisterTaskDefinition(
            bstrTaskName,
            pTask,
            TASK_CREATE_OR_UPDATE,
            vEmpty,        // User - empty variant
            vPassword,     // Password - empty variant  
            TASK_LOGON_INTERACTIVE_TOKEN,
            vEmpty,        // SDDL - empty variant
            &pRegisteredTask
        );
        
        SysFreeString(bstrTaskName);
        
        if (FAILED(hr)) {
            std::cerr << "[ERROR] RegisterTaskDefinition failed: 0x" << std::hex << hr << std::endl;
            return false;
        }
        
        std::cout << "[+] Task registered successfully" << std::endl;
        
        // Run the task immediately (equivalent to schtasks /run)
        VARIANT vRunEmpty;
        VariantInit(&vRunEmpty);
        vRunEmpty.vt = VT_EMPTY;
        
        IRunningTask* pRunningTask = NULL;
        hr = pRegisteredTask->Run(vRunEmpty, &pRunningTask);
        if (SUCCEEDED(hr)) {
            std::cout << "[+] Task started immediately" << std::endl;
            if (pRunningTask) pRunningTask->Release();
        } else {
            std::cerr << "[WARNING] Task registered but failed to start: 0x" << std::hex << hr << std::endl;
        }
        
        pRegisteredTask->Release();
        
        return true;
    }
};

int main() {
    std::cout << "\n====================================================" << std::endl;
    std::cout << "Scheduled Task COM API Persistence BSI (GIMC Test)" << std::endl;
    std::cout << "Based on Carberp malware (sanitized)" << std::endl;
    std::cout << "====================================================" << std::endl;
    std::wcout << L"Task Name: " << TASK_NAME << std::endl;
    std::cout << "Trigger: Logon (runs at user logon)" << std::endl;
    std::cout << "Payload: Writes " << LOOP_COUNT << " log entries with " << (LOOP_DELAY_MS/1000) << "s delay" << std::endl;
    std::wcout << L"Log File: " << LOG_FILE << std::endl;
    std::cout << "====================================================\n" << std::endl;
    
    ScheduledTaskPersistence task;
    
    if (!task.Initialize()) {
        std::cerr << "\n[FAILED] Could not initialize Task Scheduler" << std::endl;
        return 1;
    }
    
    if (!task.CreateTask()) {
        std::cerr << "\n[FAILED] Could not create scheduled task" << std::endl;
        return 1;
    }
    
    std::cout << "\n[SUCCESS] Scheduled task persistence installed and executed!" << std::endl;
    std::cout << "The task has been triggered immediately and will run again at next logon." << std::endl;
    std::cout << "Check log file for " << LOOP_COUNT << " entries written with " << (LOOP_DELAY_MS/1000) << "s intervals." << std::endl;
    std::wcout << L"Log file: " << LOG_FILE << std::endl;
    std::cout << "\nTo remove: cscript remove_task.js" << std::endl;
    std::wcout << L"Or run: schtasks /Delete /TN \"" << TASK_NAME << L"\" /F" << std::endl;
    std::cout << "\nTo run manually again: schtasks /Run /TN \"" << TASK_NAME << "\"" << std::endl;
    
    return 0;
}
