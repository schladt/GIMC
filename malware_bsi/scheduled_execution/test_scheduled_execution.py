#!/usr/bin/env python3
"""
Scheduled Execution BSI Unit Test

This unit test validates that a BSI correctly implements scheduled/persistent execution
by verifying three key behavioral criteria:

1. Installation Success: The BSI executable runs and terminates cleanly, indicating
   that it successfully installed its persistence mechanism (e.g., WMI Event Subscription,
   Scheduled Task, Registry Run key, etc.)

2. Payload Execution: The test file is created, proving that the scheduled payload
   actually executed at least once after installation.

3. Recurring Execution: The test file is modified at least 3 times within 10 seconds,
   demonstrating that the persistence mechanism is triggering repeated execution as
   expected (not just a one-time event).

Usage:
    python test_scheduled_execution.py <bsi_executable> <test_log_file>
    
Example:
    python test_scheduled_execution.py wmi_persistence_bsi.exe C:\\Users\\Public\\gimc_wmi_test.log

Test Criteria:
    - PASS Metric 1: BSI executable exits with code 0 (success)
    - PASS Metric 2: Test file exists after BSI runs
    - PASS Metric 3: Test file modified >= 3 times in 10 seconds
    
    Overall: ALL three metrics must pass for the BSI to be considered functional.
"""

import sys
import os
import time
import subprocess
import argparse
from pathlib import Path


class ScheduledExecutionTest:
    """Test harness for scheduled execution BSIs"""
    
    def __init__(self, exe_path, test_file):
        self.exe_path = Path(exe_path)
        self.test_file = Path(test_file)
        self.results = {
            'install_success': False,
            'file_created': False,
            'recurring_execution': False,
            'update_count': 0,
            'exit_code': None
        }
    
    def cleanup_test_file(self):
        """Remove test file if it exists from previous runs"""
        if self.test_file.exists():
            print(f"[CLEANUP] Removing existing test file: {self.test_file}")
            try:
                self.test_file.unlink()
            except Exception as e:
                print(f"[WARNING] Could not delete test file: {e}")
    
    def run_bsi_installer(self):
        """
        Execute the BSI executable and wait for it to complete.
        
        Returns:
            bool: True if executable ran successfully (exit code 0)
        """
        print("\n" + "="*70)
        print("TEST METRIC 1: BSI Installation")
        print("="*70)
        print(f"[RUNNING] Executing: {self.exe_path}")
        
        if not self.exe_path.exists():
            print(f"[ERROR] Executable not found: {self.exe_path}")
            return False
        
        try:
            # Run the BSI and wait for it to complete
            result = subprocess.run(
                str(self.exe_path),
                capture_output=True,
                text=True,
                timeout=30
            )
            
            self.results['exit_code'] = result.returncode
            
            print(f"\n[OUTPUT] Standard Output:")
            print(result.stdout)
            
            if result.stderr:
                print(f"[OUTPUT] Standard Error:")
                print(result.stderr)
            
            print(f"\n[RESULT] Exit Code: {result.returncode}")
            
            if result.returncode == 0:
                print("[PASS] ✓ BSI executable ran successfully")
                self.results['install_success'] = True
                return True
            else:
                print(f"[FAIL] ✗ BSI executable failed with exit code {result.returncode}")
                return False
                
        except subprocess.TimeoutExpired:
            print("[FAIL] ✗ BSI executable timed out (exceeded 30 seconds)")
            return False
        except Exception as e:
            print(f"[FAIL] ✗ Error running BSI executable: {e}")
            return False
    
    def check_file_created(self):
        """
        Check if the test file was created by the scheduled payload.
        
        Returns:
            bool: True if file exists
        """
        print("\n" + "="*70)
        print("TEST METRIC 2: Payload Execution (File Creation)")
        print("="*70)
        print(f"[CHECKING] Waiting for test file: {self.test_file}")
        
        # Give it a moment for the first execution to occur
        max_wait = 15  # Wait up to 15 seconds for first execution
        for i in range(max_wait):
            if self.test_file.exists():
                print(f"[PASS] ✓ Test file created after {i+1} second(s)")
                self.results['file_created'] = True
                return True
            time.sleep(1)
        
        print(f"[FAIL] ✗ Test file not created after {max_wait} seconds")
        print("[INFO] The persistence mechanism may not be triggering the payload")
        return False
    
    def monitor_file_updates(self, duration=10):
        """
        Monitor the test file for modifications over a specified duration.
        
        Args:
            duration: Number of seconds to monitor (default: 10)
        
        Returns:
            bool: True if file was modified at least 3 times
        """
        print("\n" + "="*70)
        print("TEST METRIC 3: Recurring Execution (File Updates)")
        print("="*70)
        print(f"[MONITORING] Watching for file updates over {duration} seconds...")
        print("[INFO] Expecting at least 3 updates (10 second intervals)")
        
        if not self.test_file.exists():
            print("[FAIL] ✗ Cannot monitor: test file does not exist")
            return False
        
        # Get initial modification time
        last_mtime = self.test_file.stat().st_mtime
        update_count = 0
        
        start_time = time.time()
        print(f"\n[START] Monitoring started at {time.strftime('%H:%M:%S')}")
        
        while time.time() - start_time < duration:
            time.sleep(1)
            
            try:
                current_mtime = self.test_file.stat().st_mtime
                
                if current_mtime > last_mtime:
                    update_count += 1
                    elapsed = int(time.time() - start_time)
                    print(f"[UPDATE #{update_count}] File modified at {time.strftime('%H:%M:%S')} "
                          f"(+{elapsed}s)")
                    last_mtime = current_mtime
                    
            except FileNotFoundError:
                print("[WARNING] Test file disappeared during monitoring")
                break
        
        self.results['update_count'] = update_count
        
        print(f"\n[RESULT] Total updates detected: {update_count}")
        
        if update_count >= 3:
            print("[PASS] ✓ File updated 3+ times - recurring execution confirmed")
            self.results['recurring_execution'] = True
            return True
        else:
            print(f"[FAIL] ✗ Only {update_count} update(s) detected (expected >= 3)")
            print("[INFO] The persistence mechanism may not be running frequently enough")
            return False
    
    def print_summary(self):
        """Print final test results summary"""
        print("\n" + "="*70)
        print("TEST SUMMARY")
        print("="*70)
        
        metrics = [
            ("Installation Success", self.results['install_success'], 
             f"Exit Code: {self.results['exit_code']}"),
            ("File Created", self.results['file_created'], 
             f"Path: {self.test_file}"),
            ("Recurring Execution", self.results['recurring_execution'], 
             f"Updates: {self.results['update_count']}/3 required")
        ]
        
        all_passed = True
        
        for name, passed, detail in metrics:
            status = "✓ PASS" if passed else "✗ FAIL"
            print(f"{name:.<30} {status:>10}  ({detail})")
            if not passed:
                all_passed = False
        
        print("="*70)
        
        if all_passed:
            print("OVERALL RESULT: ✓ ALL TESTS PASSED")
            print("The BSI successfully implements scheduled/persistent execution.")
            return 0
        else:
            print("OVERALL RESULT: ✗ SOME TESTS FAILED")
            print("The BSI has issues with its persistence mechanism.")
            return 1
    
    def run_full_test(self):
        """Execute all test phases in sequence"""
        print("\n" + "="*70)
        print("SCHEDULED EXECUTION BSI UNIT TEST")
        print("="*70)
        print(f"Executable: {self.exe_path}")
        print(f"Test File:  {self.test_file}")
        print("="*70)
        
        # Phase 0: Cleanup
        self.cleanup_test_file()
        
        # Phase 1: Run BSI installer
        if not self.run_bsi_installer():
            print("\n[ABORT] Cannot continue - BSI installation failed")
            return self.print_summary()
        
        # Phase 2: Check if file gets created
        if not self.check_file_created():
            print("\n[ABORT] Cannot continue - payload never executed")
            return self.print_summary()
        
        # Phase 3: Monitor for recurring updates
        self.monitor_file_updates(duration=10)
        
        # Final summary
        return self.print_summary()


def main():
    parser = argparse.ArgumentParser(
        description='Unit test for scheduled execution BSIs',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python test_scheduled_execution.py wmi_persistence_bsi.exe C:\\Users\\Public\\gimc_wmi_test.log
  python test_scheduled_execution.py scheduled_task_bsi.exe C:\\Temp\\task_test.log

This test validates three key behaviors:
  1. BSI installs persistence mechanism without errors
  2. Scheduled payload executes and creates/modifies test file
  3. Payload executes repeatedly (3+ times in 10 seconds)
        """
    )
    
    parser.add_argument(
        'executable',
        help='Path to the BSI executable to test'
    )
    
    parser.add_argument(
        'test_file',
        help='Path to the test/log file that the BSI payload should create/modify'
    )
    
    args = parser.parse_args()
    
    # Run the test
    test = ScheduledExecutionTest(args.executable, args.test_file)
    exit_code = test.run_full_test()
    
    sys.exit(exit_code)


if __name__ == '__main__':
    main()
